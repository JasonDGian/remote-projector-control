<div align="center">
<h1> Proyecto de gesti√≥n remota de proyectores </h1>
</div>
<br/>

![main-banner](https://github.com/user-attachments/assets/80230639-61c7-4886-b19c-2c296ca31889)

<div align="center">
Puedes encontrarme en <a href="https://www.linkedin.com/in/jason-david-gianmoena-959195310/"><strong>LinkedIn</strong></a>
</div>

   <br/>


<p align="center">
<a href="https://www.linkedin.com/in/jason-david-gianmoena-959195310/"> 
<img src="https://img.shields.io/badge/-Jason_David_Gianmoena-blue?style=flat-square&logo=Linkedin&logoColor=white&link=https://www.linkedin.com/in/jason-david-gianmoena-959195310/" alt="LinkedIn">
</a>
   
<br/>
<br/>
   
<div align="center">
<h2>Tecnologias</h2>
   
*Back-end*   
![Java](https://img.shields.io/badge/java-%23ED8B00.svg?style=for-the-badge&logo=openjdk&logoColor=white) 
![Spring](https://img.shields.io/badge/spring-%236DB33F.svg?style=for-the-badge&logo=spring&logoColor=white) 
![C++](https://img.shields.io/badge/C++-00599C.svg?style=for-the-badge&logo=c%2B%2B&logoColor=white) 
![MySQL](https://img.shields.io/badge/mysql-4479A1.svg?style=for-the-badge&logo=mysql&logoColor=white)

</div>
<div align="center">
   
*Front-end*   
![Node.js](https://img.shields.io/badge/node.js-339933.svg?style=for-the-badge&logo=nodedotjs&logoColor=white) 
![Vue.js](https://img.shields.io/badge/vuejs-%2335495e.svg?style=for-the-badge&logo=vuedotjs&logoColor=%234FC08D) 
![Bootstrap](https://img.shields.io/badge/bootstrap-%238511FA.svg?style=for-the-badge&logo=bootstrap&logoColor=white) 
![HTML5](https://img.shields.io/badge/html5-%23E34F26.svg?style=for-the-badge&logo=html5&logoColor=white) 
![CSS3](https://img.shields.io/badge/css3-%231572B6.svg?style=for-the-badge&logo=css3&logoColor=white) 
</div>

<div align="center">
   
*IDE y control de versiones*   
![Eclipse](https://img.shields.io/badge/Eclipse-FE7A16.svg?style=for-the-badge&logo=Eclipse&logoColor=white) ![Arduino IDE](https://img.shields.io/badge/arduino%20ide-00979D.svg?style=for-the-badge&logo=arduino&logoColor=white) ![VSCodium](https://img.shields.io/badge/codium-2f3241.svg?style=for-the-badge&logo=vscodium&logoColor=white) ![Git](https://img.shields.io/badge/git-%23F05033.svg?style=for-the-badge&logo=git&logoColor=white)
![GitHub](https://img.shields.io/badge/github-%23121011.svg?style=for-the-badge&logo=github&logoColor=white) 

*Documentaci√≥n e ilustraciones*   
![Markdown](https://img.shields.io/badge/markdown-000000.svg?style=for-the-badge&logo=markdown&logoColor=white) ![Photopea](https://img.shields.io/badge/Photopea-18A497?style=for-the-badge&logo=photopea&logoColor=white) ![Snappify](https://img.shields.io/badge/Snappify-9146FF?style=for-the-badge&logo=data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjZmZmIiB2aWV3Qm94PSIwIDAgMzIgMzIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTExLjEyIDIyLjA4YTEuNzEgMS43MSAwIDAgMS0xLjcyLTIuOTlsNy45LTQuNzVhMS43MiAxLjcyIDAgMCAxIDIuNTUgMS41NHY5LjVsLTcuOS00Ljc1eiIvPjxwYXRoIGQ9Ik0yMy42MyAxMC4zYTEuNzIgMS43MiAwIDAgMSAxLjcyIDIuOTlsLTcuOSAxLjc1YTEuNzEgMS43MSAwIDAgMS0yLjU1LTEuNTR2LTkuNWw3LjkgMS43NXoiLz48L3N2Zz4=&logoColor=white) ![Draw.io](https://img.shields.io/badge/Draw.io-F08705?style=for-the-badge&logo=diagramsdotnet&logoColor=white)

</div>

<br/>
<br/>

## üí° Acerca de...
Este proyecto presenta una **soluci√≥n centralizada para el control y monitoreo remoto de proyectores** instalados en entornos educativos. Su funcionamiento se basa en una infraestructura compuesta por una **plataforma web**, **microcontroladores ESP32** y un **servidor centralizado**, permitiendo a los usuarios autorizados **encender, apagar y consultar el estado** de los proyectores en tiempo real, desde cualquier dispositivo con acceso a la red.
   
El objetivo principal es **optimizar el uso de los recursos tecnol√≥gicos del centro**, reduciendo tanto el **consumo energ√©tico innecesario** como el **tiempo que el personal dedica a tareas manuales de supervisi√≥n**. Adem√°s, se busca **automatizar operaciones cr√≠ticas**, como el **apagado programado de todos los proyectores al finalizar la jornada escolar**, mejorando as√≠ la eficiencia operativa y garantizando un entorno m√°s sostenible.

![gif-escaparate](https://github.com/user-attachments/assets/de498bc6-9b29-4363-ab3b-6db4e868c57e)


<img width="49%" src="https://github.com/user-attachments/assets/944062b8-011b-479d-a441-0b71180bef38" >

<img width="49%" src="https://github.com/user-attachments/assets/3c2ac355-e9ae-4c52-8087-5ccc73259d3e" >

<img width="49%" src="https://github.com/user-attachments/assets/d3a8eb90-e339-4b07-8ce2-d28e8d2921b0" >

<img width="49%" src="https://github.com/user-attachments/assets/9a15b69d-3b57-4b80-8366-7ce9a721d76e" >

</p>

<!--
# üçÄ Antes de comenzar...
¬°Hola!   
Bienvenido a mi repositorio.    
Mi nombre es **Jason**, y puedes encontrarme en [LinkedIn](https://www.linkedin.com/in/jason-david-gianmoena-959195310/).

Este proyecto representa mi Trabajo de Fin de Ciclo para el grado de **Desarrollo de Aplicaciones Multiplataforma**. En √©l, he querido aplicar y consolidar muchos de los conocimientos adquiridos a lo largo de mi formaci√≥n y mi aventura en el mundo de la tecnolog√≠a.

**Aqu√≠ podr√°s encontrar:** 
- El desarrollo de un servidor en `Java` utilizando el `framework Spring Boot`.
- La configuraci√≥n de un microcontrolador `ESP32` codificado en `C++ Arduino Flavour` que se comunica y trabaja en sincron√≠a con dicho servidor.
- Gran parte de la documentaci√≥n t√©cnica que he ido generando durante el proceso de investigaci√≥n y desarrollo.

>[!IMPORTANT]
>La mayor√≠a de las im√°genes que encontrar√°s aqu√≠, as√≠ como las explicaciones de los conceptos tratados, han sido elaboradas por m√≠.
>Si detectas alg√∫n error, ya sea en las ilustraciones o en los textos, no dudes en hac√©rmelo saber. ¬°Estar√© encantado de corregirlo y mejorar la documentaci√≥n con tu ayuda!
-->
       
<br/>

---

<!--   
# üìö √çndice
Este √≠ndice interactivo contiene enlaces directos a su secci√≥n espec√≠fica. Para utilizarlo, selecciona el apartado al que quieres llegar y obten as√≠ una r√°pida y c√≥moda lectura.

  
1. [üëã Introducci√≥n](#introduccion)     
2. [üìë Descripci√≥n del Proyecto](#descripci√≥n-del-proyecto)  
   - [Componentes](#componentes)  
   - [Objetivos](#objetivos)  
   - [Funcionamiento General](#funcionamiento-general)  
3. [üõ†Ô∏è Arquitectura y flujo de operaciones logicas](#detalles-tecnicos-y-funcionales)  
   - [Funcionamiento del Sistema](#funcionamiento-del-sistema)  
   - [Orden de Operaciones](#orden-de-operaciones)  
4. [üõ¢Ô∏è Esquema de Informaci√≥n de Base de Datos](#esquema)  
   - [Tablas del Sistema](#tablas)  
   - [Relaciones del Sistema](#relaciones-sistema)  
5. [üé® Interfaz Gr√°fica y Roles de Usuario](#interfaz)  
   - [Roles de Usuario](#administrador)  
   - [Dise√±o Actual de la Interfaz](#dise√±o-actual-de-la-interfaz)  
6. [üì° Documentaci√≥n API REST - Gesti√≥n Remota de Proyectores](#api-rest)  
   - [Controlador ProjectorRemoteAgentController](#projectorremoteagentcontroller)  
   - [Controlador ProjectorCommonsController](#projectorcommonscontroller)  
   - [Conmtrolador ProjectorAdminController](#projectoradmincontroller)  
7. [üß∞ Hardware Especial - Microcontroladores y M√≥dulos A√±adidos](#hardware-especial)  
   - [ESP32 - Placa Principal](#esp32)  
   - [Convertidor RS232 a TTL](#rs232)  
   - [M√≥dulo MicroSD SPI](#microsd)  
   - [Esquema de Conexi√≥n de Componentes](#esquema-de-conexion)  
   - [üìå Configuraci√≥n Puerto RS232](#configuraci√≥n-rs232)  
   - [üìå Configuraci√≥n M√≥dulo MicroSD SPI](#configuraci√≥n-spi)
8. [üì§ Carga de datos al servidor.](#carga-datos-servidor)

<br/>
 -->
<!--
<div align="center">   
   
  # üéØ Introducci√≥n
</div>



En el **IES J√°ndula**, numerosos espacios como aulas, salas de conferencias y el auditorio est√°n equipados con proyectores audiovisuales montados en el techo. La gran cantidad de estos dispositivos hace que su supervisi√≥n manual resulte ineficiente, demandando tiempo y esfuerzo tanto del profesorado como del personal administrativo.

Actualmente, el control de encendido y apagado se realiza mediante mandos a distancia de radiofrecuencia o infrarrojos, dependiendo del modelo. Esta soluci√≥n presenta m√∫ltiples limitaciones: la p√©rdida de un mando puede dejar inoperativo un proyector durante d√≠as o semanas, afectando directamente la continuidad de las clases y, en consecuencia, la calidad de la ense√±anza.

Adem√°s, la incertidumbre sobre si un proyector ha quedado encendido obliga al personal a recorrer f√≠sicamente las aulas para comprobarlo, lo que genera una p√©rdida de tiempo y un consumo energ√©tico innecesario.

<div align="center"> 
   
 ### üöÄ ¬øPor qu√© este proyecto?
</div>

Este proyecto nace como respuesta a estos desaf√≠os. Su objetivo es **centralizar y automatizar la gesti√≥n de los proyectores** del centro educativo mediante una plataforma web intuitiva y accesible. A trav√©s de esta soluci√≥n:

- Un **cliente web** permite a los usuarios enviar √≥rdenes con un solo clic.
- Un **servidor centralizado** se encarga de procesar las solicitudes y coordinar la comunicaci√≥n.
- **Microcontroladores ESP32**, instalados junto a cada proyector, ejecutan las acciones correspondientes (encender, apagar, reportar estado).

![image](https://github.com/user-attachments/assets/f63f3abd-5990-4926-be60-a3fbe36e410d)

De esta forma, cualquier docente autorizado podr√° controlar uno o varios proyectores desde su dispositivo, de forma **r√°pida, c√≥moda y remota**, sin necesidad de desplazarse ni depender de mandos f√≠sicos.



   
<div align="center">   

<br/>

<br/>

<br/>

-->
   
# üìå Tabla de contenidos. 
</div>
<!-- En esta tabla encontrar√°s acceso a documentos que explican distintos aspectos del proyecto, tanto a nivel t√©cnico como general. Cada secci√≥n incluye un enlace directo al documento correspondiente. 
<br/>
<br/>
-->

**‚ÑπÔ∏è M√°s informaci√≥n sobre el proyecto**  
En esta secci√≥n se explica en detalle el prop√≥sito del proyecto, as√≠ como sus objetivos y componentes fundamentales.  
üîπ [Ir a secci√≥n..](./src/main/resources/documentacion/acerca-del-proyecto.md)

**üõ†Ô∏è Arquitectura general y flujo de operaciones**  
Esta secci√≥n describe la arquitectura de la aplicaci√≥n, as√≠ como el flujo l√≥gico de operaciones que ocurre durante el funcionamiento normal de los agentes, el servidor y los clientes.  
üîπ [Ir a secci√≥n..](./src/main/resources/documentacion/arquitectura-y-flujo.md)

**üõ¢Ô∏è Esquema de base de datos y tablas**  
Detalla el dise√±o del esquema de la base de datos, incluyendo la descripci√≥n de las tablas y sus relaciones.  
üîπ [Ir a secci√≥n..](./src/main/resources/documentacion/esquema-y-tablas.md)

**üé® Interfaz gr√°fica de usuario (GUI)**  
Describe y explica la interfaz gr√°fica de la aplicaci√≥n, mostrando las vistas y detallando sus funcionalidades y caracter√≠sticas.  
üîπ [Ir a secci√≥n..](./src/main/resources/documentacion/interfaz-grafica-y-roles.md)

**üì° Documentaci√≥n de la API ‚Äì Gesti√≥n remota de proyectores**  
Documenta los puntos de acceso de la API REST expuesta por el servidor Spring Boot para la gesti√≥n remota de proyectores.  
üîπ [Ir a secci√≥n..](./src/main/resources/documentacion/api-rest.md)

**üß∞ Hardware especial ‚Äì Microcontroladores y m√≥dulos adicionales**  
Describe el hardware especial utilizado en el proyecto, incluyendo sus fichas t√©cnicas, la configuraci√≥n de pines y los esquemas de conexi√≥n de los m√≥dulos integrados.  
üîπ [Ir a secci√≥n..](./src/main/resources/documentacion/hardware-especial.md)

**üìü Codificaci√≥n y diagramas de flujo**  
En esta secci√≥n encontrar√°s explicaciones sobre las funciones contenidas en el fichero gui√≥n que configura el agente remoto asi como diagramas de flujo que ilustran su l√≥gica.    
üîπ [Ir a secci√≥n..](./src/main/resources/documentacion/codificacion.md)

**üìÑ Instrucciones y notas de uso**  
En esta secci√≥n encontrar√°s instrucciones y notas importantes sobre c√≥mo usar la aplicaci√≥n y las reglas a seguir, tanto para su configuraci√≥n inicial como para su uso en producci√≥n.  
üîπ [Ir a secci√≥n..](./src/main/resources/documentacion/instrucciones-de-uso.md)



   
<!--
<a name="introduccion"></a>
# 1. üëã Introducci√≥n.
En el centro educativo IES J√°ndula, numerosas aulas, salas de conferencias, el auditorio y otros espacios habilitados est√°n equipados con proyectores audiovisuales montados en el techo o cielo raso. Debido a la gran cantidad de estos dispositivos, supervisar su estado de funcionamiento de manera manual supone un desaf√≠o considerable y una gran inversi√≥n de tiempo para el profesorado y el personal administrativo.
   
Actualmente, el encendido y apagado de estos proyectores se realiza mediante mandos a distancia por radiofrecuencia o infrarrojos, seg√∫n el modelo. Esto implica que, si un mando se extrav√≠a, el proyector quedar√≠a inutilizable hasta que el centro apruebe la adquisici√≥n de un reemplazo para un mando compatible. Esta situaci√≥n no solo limita la disponibilidad del equipo, sino que tambi√©n dificulta la labor docente y, en consecuencia, puede afectar o impactar directamente la calidad de la ense√±anza.

Adem√°s, cuando existe la duda de si un proyector ha quedado encendido, un docente debe recorrer las aulas para comprobarlo y apagarlo manualmente. Esto no solo supone una p√©rdida de tiempo para el profesorado y los administradores, sino que tambi√©n puede derivar en un consumo innecesario de energ√≠a.

Para solucionar estos problemas, surge la necesidad de implementar un sistema de monitoreo y gesti√≥n remota de proyectores, que permita supervisar su estado en tiempo real y controlarlos de forma eficiente, optimizando as√≠ el uso de los recursos tecnol√≥gicos del centro.

<br/>
   
![image](https://github.com/user-attachments/assets/f63f3abd-5990-4926-be60-a3fbe36e410d)

<br/>

---
    
<a name="descripci√≥n-del-proyecto"></a>   
# 2. üìë Descripci√≥n del proyecto.
Este proyecto tiene como objetivo desarrollar una soluci√≥n para supervisar en tiempo real el estado de los proyectores y permitir su encendido y apagado de forma remota. Con esta implementaci√≥n, se optimizar√° la gesti√≥n de estos dispositivos, se reducir√° el consumo energ√©tico causado por olvidos y se facilitar√° el trabajo del personal autorizado.

## Componentes.
Para su desarrollo, el proyecto integra diversas tecnolog√≠as de hardware y software, entre las que destacan:
- **Servidor**: Implementado con Spring Boot, ser√° el encargado de recibir y gestionar las solicitudes de los usuarios.
- **Microcontroladores ESP32**: Actuar√°n como agentes remotos, encargados de ejecutar las √≥rdenes recuperadas desde el servidor.
- **Cliente web**: Desarrollado en Vue.js, servir√° como interfaz para los usuarios autenticados y autorizados.

## Objetivos.
Los objetivos principales de este proyecto son:
**Centralizar la gesti√≥n de los proyectores:**
El proyecto proporcionar√° una plataforma central con acceso limitado desde la cual los usuarios podr√°n gestionar determinadas acciones para los proyectores, sin necesidad de estar en el mismo aula donde se encuentra el proyector.   
- **Proporcionar una visi√≥n global del estado de los proyectores asociados**, permitiendo un monitoreo eficiente. 
- **Facilitar la gesti√≥n remota mediante una interfaz intuitiva y f√°cil de usar**, que permita el env√≠o de √≥rdenes de encendido y apagado de manera r√°pida y sencilla.
- **Mejorar la eficiencia operativa del personal docente y administrativo**, eliminando la necesidad de revisar manualmente cada proyector.
- **Sentar las bases** para futuras mejoras y la posible expansi√≥n de funcionalidades seg√∫n estas se presenten.

## Funcionamiento general.

<img src="https://github.com/user-attachments/assets/f1638125-b231-42a0-b0b4-7ee2a07666b2" alt="usuario" width="80px" align="right">

**1. Interacci√≥n del Usuario.**    
A trav√©s de la interfaz web, los usuarios podr√°n enviar √≥rdenes para encender o apagar los proyectores registrados en la base de datos. Podr√°n decidir si seleccionar una o m√°s unidades fisicas a las que hacer llegar la orden.   
    
<hr style="border:1px solid gray">
         
<img src="https://github.com/user-attachments/assets/b064e986-b389-418f-bb04-7e73a1241b4c" alt="usuario" width="80px" align="right">

**2. Procesamiento en el Servidor.**   
El servidor Spring Boot recibir√° las solicitudes y verificar√° los permisos del usuario.     
Si la solicitud es v√°lida, almacenar√° la orden en la base de datos para su posterior consulta y ejecuci√≥n.   

    
<hr style="border: 1px solid #ccc;"/>

    

<img src="https://github.com/user-attachments/assets/8057fa84-2b9f-40ef-9284-a7779deb14ab" alt="usuario" width="80px" align="right">

**3. Ejecuci√≥n por el Microcontrolador.**    
El ESP32 (Agente Remoto) consultar√° peri√≥dicamente la base de datos del servidor.   
Si hay tareas pendientes asociadas a su proyector, enviar√° la orden correspondiente al proyector para que este la ejecute.    
Una vez ejecutada la orden recibida, responder√° con el resultado de la operaci√≥n.    
    
Gracias a este sistema, se lograr√° una gesti√≥n eficiente y automatizada de los proyectores, asegurando su uso √≥ptimo y evitando consumos innecesarios de energ√≠a.

<br/>

--->

   <!-- 
<a name="detalles-tecnicos-y-funcionales"></a>   
# 3. üõ†Ô∏è Arquitectura y flujo de operaciones logicas.
## Funcionamiento del sistema.
La arquitectura utilizada en el desarrollo del proyecto sigue un modelo cliente-servidor, que para fines ilustrativos se puede dividir en dos partes o `lados¬¥:

1. **Lado usuario:** Aqu√≠ se presenta la interfaz gr√°fica web, donde los usuarios pueden seleccionar la unidad f√≠sica a la que desean enviar una tarea (un proyector espec√≠fico ubicado en un aula) y definir la tarea a ejecutar. Una vez registrada, la tarea se almacena en la base de datos del servidor junto con informaci√≥n relevante, como la fecha de solicitud, el usuario que la registr√≥, la instrucci√≥n deseada y el modelo del proyector en cuesti√≥n.

2. **Lado agente remoto (microcontrolador):** Peri√≥dicamente, el agente remoto asociado a cada proyector consulta la API del microservicio para verificar si hay tareas pendientes para √©l en la cola de ejecuci√≥n. Si existen tareas asignadas, el servidor responde enviando la instrucci√≥n correspondiente seg√∫n el modelo del proyector. El microcontrolador recibe la instrucci√≥n, la transmite al proyector a trav√©s de su interfaz de comunicaci√≥n, y √©ste la ejecuta.

Adem√°s, el sistema incluye un mecanismo de actualizaci√≥n del estado de las tareas, que no se detalla en esta explicaci√≥n y ser√° abordado m√°s adelante.

![image](https://github.com/user-attachments/assets/c8482c0b-a148-4e50-bc02-ba7a3e1c8846)

---

## Orden de operaciones.
En el siguiente diagrama se representa el orden de operaciones en el flujo de trabajo de los clientes, servidor y agente remoto.
    
1. Un usuario autenticado en el sistema env√≠a una solicitud para ejecutar una acci√≥n en un proyector espec√≠fico.
2. El servidor almacena la solicitud en la base de datos, dentro de la tabla "Servidor Evento".
3. Peri√≥dicamente, un agente remoto consulta al servidor en busca de nuevas tareas.
4. El servidor verifica la base de datos y, si existen eventos pendientes para el proyector en cuesti√≥n, recupera los datos de la instrucci√≥n.
5. Luego, el servidor formatea la instrucci√≥n y la env√≠a al agente remoto.
6. El agente remoto recibe la instrucci√≥n y la convierte a un formato compatible con el proyector, envi√°ndosela.
7. Seg√∫n la respuesta del proyector, el agente remoto env√≠a una actualizaci√≥n de estado al servidor.
8. Finalmente, el servidor actualiza el estado del evento en la tabla "Servidor Evento".    
   
![imagen](https://github.com/user-attachments/assets/b9ad96ac-6823-4789-9111-cc401183c552)

-->
<!--
<a name="esquema"></a>   
# 4. Esquema de informaci√≥n de base de datos.
En esta secci√≥n se describe el sistema de informaci√≥n utilizado en el proyecto para la gesti√≥n y control remoto de proyectores en el centro, utilizando una arquitectura basada en eventos.

**Dise√±o inicial**.   
Aunque este dise√±o inicial no es el que finalmente se ha implementado, sirve para entender el funcionamiento general del sistema, el cual luego se simplific√≥ en el modelo que se describe a continuaci√≥n.

<p align="center">
  <img src="https://github.com/user-attachments/assets/afabca63-7e8b-44a2-9f1a-52c682dd4ab7" alt="esquema">
</p>

**Dise√±o final simplificado**.    
Este esquema simplificado permite gestionar proyectores de manera eficiente, asegurando un control centralizado y un historial detallado de las acciones realizadas. 
    
<p align="center">
   <img src="https://github.com/user-attachments/assets/fb395e7f-1bce-4257-94a9-b37ee9aa9ea6" alt="esquema">
</p>

![imagen](https://github.com/user-attachments/assets/d1f32038-b1ad-44b7-b6d2-f8507ed0724b)

---
<a name="tablas"></a> 
## :card_index: **Tabla `Projector`**  
<img width=240px src="https://github.com/user-attachments/assets/0e458134-ac0c-4830-b1ef-1e426030550e" alt="proyectores" align="right">
    
Representa una unidad f√≠sica de proyector dentro del centro educativo.  

### **Campos:**  
- `classroom` (**PK**) ‚Üí Identificador √∫nico del aula donde se encuentra el proyector.  
- `floor` ‚Üí Planta en la que se encuentra el aula.  
- `model` ‚Üí Modelo del proyector instalado.
- `projector` ‚Üí Representa el estado de "Encendido" o "Apagado" del proyector.

### **Relaciones:**  
- Relaci√≥n **uno a muchos** con `ServerEvent`, permitiendo registrar eventos asociados a cada proyector.  

üóíÔ∏è **Descripci√≥n:**  
Cada aula tiene un solo proyector, identificado de manera √∫nica por el aula donde est√° instalado.  

---

## :card_index: **Tabla `Command`**  
<img width=240px src="https://github.com/user-attachments/assets/40cea64f-8e3f-467f-97e3-e24458399989" alt="comandos" align="right">

Almacena las instrucciones necesarias para interactuar con los proyectores.  

### **Campos:**  
- `modelName` (**PK**) ‚Üí Modelo del proyector al que aplica el comando.  
- `action` (**PK**) ‚Üí Acci√≥n que se desea ejecutar (encender, apagar, cambiar fuente, etc.).  
- `command` ‚Üí C√≥digo de la instrucci√≥n que debe enviarse al dispositivo.  

### **Relaciones:**  
- Relaci√≥n **uno a muchos** con `ServerEvent`, permitiendo registrar eventos asociados a cada comando ejecutado.  

üóíÔ∏è **Descripci√≥n:**  
Permite mapear cada modelo de proyector con sus respectivas acciones y las instrucciones necesarias para ejecutarlas.  

---

## :card_index: **Tabla `ServerEvent`**  
<img width=240px src="https://github.com/user-attachments/assets/a787179b-b319-43ba-8ec6-31c13243227b" alt="eventos" align="right">


Registra las solicitudes de los usuarios para ejecutar comandos sobre los proyectores. 

### **Campos:**  
- `eventId` (**PK**) ‚Üí Identificador √∫nico del evento.  
- `command` (**FK**) ‚Üí Comando asociado a la acci√≥n solicitada.  
- `projector` (**FK**) ‚Üí Proyector sobre el cual se ejecuta la acci√≥n.  
- `user` ‚Üí Usuario autor que ha realizado la solicitud.  
- `dateTime` ‚Üí Fecha y hora en que se registr√≥ la solicitud.  
- `actionStatus` ‚Üí Estado de la solicitud ([ver secci√≥n estados](#clipboard-posibles-estados-de-los-eventos)).  

### **Relaciones:**  
- Relaci√≥n **muchos a uno** con `Command` (cada evento est√° asociado con un comando espec√≠fico).  
- Relaci√≥n **muchos a uno** con `Projector` (cada evento est√° asociado a un proyector espec√≠fico).  

üóíÔ∏è **Descripci√≥n:**  
Esta tabla act√∫a como un 'buffer' de eventos. Es una tabla intermedia que se ve afectada por el borrado de registros de las tablas **`Command`** y **`Actions`**. Su objetivo es formar el registro que luego viene copiado en la tabla **`Server Event History`**.  

**Posibles estados de los eventos**  
Los eventos que el servidor gestiona pueden darse en 5 posibles estados distintos.  
- **PENDING**: La acci√≥n ha sido creada, pero no enviada.  
- **SERVED**: La acci√≥n ha sido enviada al proyector.  
- **EXECUTED**: La acci√≥n se ejecut√≥ correctamente.  
- **CANCELED**: La solicitud fue cancelada antes de ejecutarse.  
- **ERROR**: Ocurri√≥ un error en la ejecuci√≥n de la acci√≥n.  

---

## :card_index: **Tabla `ServerEventHistory`**  
<img width=240px src="https://github.com/user-attachments/assets/4ee8c396-4d07-48e3-aff4-f6d067a64e2d" alt="historial" align="right">


Almacena las ordenes que son servidas a los agentes remotos. Es la tabla que contiene los registros que realmente cuentan.

### **Campos:**  
- `eventId` (**PK**) ‚Üí Identificador √∫nico del evento.
- `accion` ‚Üí Nombre de la acci√≥n a realizar.
- `actionStatus` ‚Üí Estado de la solicitud ([ver secci√≥n estados](#clipboard-posibles-estados-de-los-eventos)).
- `classroom` ‚Üí Aula en la que se encuentra el proyector.
- `command` ‚Üí Comando asociado a la acci√≥n solicitada.
- `dateTime` ‚Üí Fecha y hora en que se registr√≥ la solicitud.
- `floor` ‚Üí Planta donde se encuentra el aula.
- `model_name` ‚Üí Nombre del modelo del proyector. 
- `user` ‚Üí Usuario autor que ha realizado la solicitud.  

üóíÔ∏è **Descripci√≥n:**  
Esta tabla act√∫a como una cola de eventos para gestionar la ejecuci√≥n de acciones sobre los proyectores. Es la tabla desde la cual se recuperan las tareas de los microcontroladores y donde vendr√°n realmente actualizados. Es la tabla cuyos registros son visibles a los usuarios desde el front web. Su objetivo es almacenar, recuperar, mostrar y actualizar los registros que vienen servidos a los agentes remotos.

---

<a name="relaciones-sistema"></a>   
## :left_right_arrow: **Relaciones del Sistema**  
- `Projector` se relaciona con `ServerEvent` a trav√©s del aula (`classroom`).  
- `Command` se relaciona con `ServerEvent` mediante `modelName` y `action`.  
- `ServerEvent` gestiona las interacciones entre `Projector` y `Command`.  

>[!IMPORTANT]
> Aunque la tabla `ServerEventHistory` no tiene una relaci√≥n directa con `ServerEvent`, su contenido depende completamente de esta √∫ltima a nivel program√°tico. Cada vez que se inserta un nuevo registro en `ServerEvent`, el servidor crea autom√°ticamente una copia id√©ntica en `ServerEventHistory`.
>Sin embargo, si un registro de `ServerEvent` es eliminado, su correspondiente copia en `ServerEventHistory` permanece intacta. Esta estrategia permite conservar un historial de eventos registrado, independientemente de eliminaciones en cascada que puedan producirse desde las tablas `Command` o `Projector` hacia `ServerEvent`.
      
--- -->

<!--
<a name="interfaz"></a>   
# 5. üé® Interfaz Gr√°fica y Roles de Usuario
>[!NOTE]
>Aunque la interfaz gr√°fica es un proyecto independiente que queda fuera del alcance de este desarrollo y no est√° incluida en este repositorio, en esta secci√≥n se ofrecen algunos datos √∫tiles sobre c√≥mo el sistema est√° dise√±ado para integrarse con dicha interfaz.

La aplicaci√≥n est√° pensada para ser utilizada por tres tipos de usuarios, cada uno con roles y permisos espec√≠ficos:
    
<a name="administrador"></a>   
### üìã Administrador.
El administrador tiene acceso a funcionalidades avanzadas para la gesti√≥n del sistema, como la carga de datos, la eliminaci√≥n de registros y otras operaciones desde el panel de control.

<a name="usuario"></a>   
### üë± Usuario
Los usuarios est√°ndar disponen de las funcionalidades b√°sicas de la aplicaci√≥n, tales como el control remoto de los proyectores y la consulta del estado de los eventos.

<a name="agentes-remotos"></a>   
### üõ∞Ô∏è Agentes remotos
Los agentes remotos (microcontroladores asociados a los proyectores) cuentan √∫nicamente con permisos para consultar las tareas disponibles para su proyector asociado, recuperar parametros de configuraci√≥n dinamicos y reportar al servidor el √©xito o fallo de las instrucciones ejecutadas.

<a name="dise√±o-actual-de-la-interfaz"></a>   
## üñåÔ∏è Dise√±o actual de la interfaz.
<table border="1" style="width: 100%; table-layout: fixed;">
  <thead>
    <tr>
      <th>DESCRIPCI√ìN</th>
      <th>ACCESO</th>
      <th>IMAGEN</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="padding: 10px; vertical-align: top;">
        <strong>Panel de control remoto & historial de eventos</strong><br>
      Esta vista permite al administrador y al usuario gestionar el env√≠o de √≥rdenes a los proyectores del centro. Se pueden filtrar por ubicaci√≥n y modelo, seleccionar proyectores y enviar √≥rdenes (con un intervalo m√≠nimo de 20 segundos). Adem√°s, se muestra un historial de eventos con su estado actual, junto con herramientas de b√∫squeda y paginaci√≥n para facilitar la navegaci√≥n.
      </td>
      <td style="text-align: center; vertical-align: top;">Administrador<br/>Usuario</td>
      <td style="text-align: center;">
        <a href="https://github.com/user-attachments/assets/8f888cc9-3110-4461-a947-c005eeef7761" target="_blank">
          <img src="https://github.com/user-attachments/assets/8f888cc9-3110-4461-a947-c005eeef7761" alt="Control Remoto">
        </a>
      </td>
    </tr>
    <tr>
      <td style="padding: 10px; vertical-align: top;">
        <strong>Panel de administraci√≥n</strong><br>
        En esta vista, el administrador podr√° gestionar la carga de datos por ficheros CSV y eliminaci√≥n de registros del servidor, as√≠ como acceder a una vista r√°pida del estado de los eventos y la cantidad total de registros activos.
      </td>
      <td style="text-align: center; vertical-align: top;">Administrador</td>
      <td style="text-align: center;">
        <a href="https://github.com/user-attachments/assets/ee8d4575-7c86-4abe-bd53-643ff9048670" target="_blank">
          <img src="https://github.com/user-attachments/assets/ee8d4575-7c86-4abe-bd53-643ff9048670" alt="Administraci√≥n">
        </a>
      </td>
       </tr>
      </tbody>
</table>


>[!TIP]
>Pincha en la imagen para ampliarla.</p>

-->
<!--
<a name="api-rest"></a>   
# 6. üì° Documentaci√≥n API REST - Gesti√≥n Remota de Proyectores
Esta secci√≥n describe los endpoints disponibles del servidor backend desarrollado en Spring Boot para la gesti√≥n remota de proyectores.
   
---
   
<a name="ProjectorRemoteAgentController"></a>   
## 1. ProjectorRemoteAgentController
Endpoints exclusivos para los agentes remotos (ESP32).
   
### üîµ `GET /projectors/server-events`
- **Descripci√≥n**: Devuelve la acci√≥n a ejecutar por un proyector.
- **Par√°metros requeridos**:
  - `aula` (string): Identificador del aula.
  - `estado` (string): Estado del proyector en el momento de realizar la petici√≥n.
- **Acceso**: Cliente Proyector
- **Respuestas**:
  - `200 OK`: Acci√≥n encontrada
  - `204 No Content`: Sin acci√≥n
  - `404 Not Found`: Proyector no registrado
  - `500 Internal Server Error`: Error interno
   
---
   
### üü° `PUT /projectors/server-events`
- **Descripci√≥n**: Actualiza el estado de un evento.
- **Par√°metros requeridos**:
  - `eventId` (string): Id del evento a actualizar.
  - `classroom` (string): Aula en la que se encuentra el proyector.
  - `rarc` (string): Remote Agent Response Code - Codigo que el proyector proporciona al Agente Remoto.
- **Acceso**: Cliente Proyector
- **Respuestas**:
  - `200 OK`: √âxito
  - `404 Not Found`: Evento no encontrado
  - `500 Internal Server Error`: Error interno
 
### üîµ `GET /projectors/config-params`
- **Descripci√≥n**: Permite recuperar parametros de configuraci√≥n en modo dinamico y adaptable en futuro a las necesidades del agente remoto o proyector.
- **Par√°metros requeridos**:
  - `projectorClassroom` (string): Aula en la que se encuentra el proyector.
- **Acceso**: Cliente Proyector
- **Respuestas**:
  - `200 OK`: √âxito
  - `404 Not Found`: Evento no encontrado
  - `500 Internal Server Error`: Error interno

---

<a name="ProjectorCommonsController"></a>   
## 2. ProjectorCommonsController

Endpoints compartidos por administradores y usuarios.

### üü¢ `POST /projectors/server-events`
- **Descripci√≥n**: Obtiene eventos del servidor filtrados.
- **Cuerpo**: `EventFilterObject`
- **Respuestas**: `200 OK`

#### üî∏ EventFilterObject

Objeto de transferencia de datos (DTO) utilizado para filtrar eventos del servidor. Representa el conjunto de criterios por los cuales los eventos pueden ser ordenados o filtrados en la p√°gina.

| Campo         | Tipo           | Descripci√≥n                             |
|---------------|----------------|---------------------------------------|
| eventId       | Long           | ID √∫nico del evento (por ejemplo, "1"). |
| actionName    | String         | Acci√≥n que debe realizar el evento.    |
| modelName     | String         | Modelo del proyector involucrado.      |
| classroomName | String         | Aula donde ocurre el evento.            |
| floorName     | String         | Piso donde ocurre el evento.            |
| user          | String         | Usuario que origin√≥ el evento.          |
| dateTime      | LocalDateTime  | Fecha y hora de creaci√≥n del evento.   |
| actionStatus  | String         | Estado del evento.                      |

---

### üü¢ `POST /projectors/server-events-batch`
- **Descripci√≥n**: Crea m√∫ltiples eventos.
- **Cuerpo**: `ServerEventBatchDto`
- **Respuestas**:
  - `201 Created`
  - `400 Bad Request`
  - `500 Internal Server Error`

#### üî∏ ServerEventBatchDto

Objeto de transferencia de datos (DTO) utilizado para crear un evento en el servidor para una acci√≥n sobre una lista dada de proyectores. Simplifica la solicitud y el proceso de creaci√≥n del evento en el servidor.

| Campo         | Tipo                | Descripci√≥n                                           |
|---------------|---------------------|-------------------------------------------------------|
| action        | String              | Acci√≥n que se realizar√°. Se refiere a la instrucci√≥n espec√≠fica para cada proyector. |
| projectorList | List<ProjectorDto>   | Lista de proyectores a los que se enviar√° la acci√≥n. |

---

### üîµ `GET /projectors/projector-models`
- **Descripci√≥n**: Lista todos los modelos de proyectores.
- **Respuestas**:
  - `200 OK`
  - `500 Internal Server Error`

---

### üîµ `GET /projectors/floors`
- **Descripci√≥n**: Lista todas las plantas.
- **Respuestas**:
  - `200 OK`
  - `204 No Content`
  - `500 Internal Server Error`

---

### üîµ `GET /projectors/event-states`
- **Descripci√≥n**: Devuelve todos los estados posibles de un evento.
- **Respuestas**: `200 OK`

---

### üîµ `GET /projectors/classrooms`
- **Descripci√≥n**: Lista aulas de una planta espec√≠fica.
- **Par√°metros**: `floor` (string)
- **Respuestas**:
  - `200 OK`
  - `204 No Content`
  - `500 Internal Server Error`

---

### üîµ `GET /projectors/actions`
- **Descripci√≥n**: Lista las acciones disponibles.
- **Respuestas**:
  - `200 OK`
  - `500 Internal Server Error`

---

<a name="ProjectorAdminController"></a>   
## 3. ProjectorAdminController

Endpoints exclusivos para el rol administrador.

### üü¢ `POST /projectors/parse-multifile`
- **Descripci√≥n**: Carga archivos CSV con comandos y proyectores.// Llama la activity.
startActivity(intent)
- **Par√°metros**: `projectorsFile`, `commandsFile` (multipart/form-data)
- **Respuestas**:
  - `200 OK`
  - `500 Internal Server Error`

---

### üü¢ `POST /projectors/commands-page`
- **Descripci√≥n**: Lista comandos con filtros opcionales.
- **Par√°metros**:
  - `modelName` (opcional)
  - `action` (opcional)
- **Respuestas**:
  - `200 OK`
  - `400 Bad Request`
  - `500 Internal Server Error`

---

### üü¢ `POST /projectors/actions-page`
- **Descripci√≥n**: Devuelve acciones paginadas.
- **Respuestas**:
  - `200 OK`
  - `500 Internal Server Error`

---

### üîµ `GET /projectors/projectors`
- **Descripci√≥n**: Lista proyectores paginados y filtrados.
- **Par√°metros**:
  - `criteria`, `classroom`, `floor`, `model` (opcional)
- **Respuestas**:
  - `200 OK`
  - `500 Internal Server Error`

---

### üî¥ `DELETE /projectors/projectors`
- **Descripci√≥n**: Elimina proyectores seleccionados.
- **Cuerpo**: Lista de `ProjectorInfoDto`
- **Respuestas**:
  - `200 OK`
  - `500 Internal Server Error`

#### üî∏ProjectorInfoDto

Objeto de transferencia de datos (DTO) que representa informaci√≥n de un proyector. Proporciona una representaci√≥n simplificada de la entidad proyector y sus detalles asociados. Usado para devolver resultados paginados.

| Campo     | Tipo   | Descripci√≥n                              |
|-----------|--------|------------------------------------------|
| model     | String | Modelo del proyector.                    |
| classroom | String | Aula donde se encuentra el proyector.   |
| floorname | String | Nombre del piso donde est√° ubicado el proyector. |

---

### üîµ `GET /projectors/general-overview`
- **Descripci√≥n**: Devuelve conteo general registros del sistema.
- **Respuestas**:
  - `200 OK`
  - `500 Internal Server Error`

---

### üîµ `GET /projectors/events-overview`
- **Descripci√≥n**: Devuelve estad√≠sticas generales de eventos.
- **Respuestas**:
  - `200 OK`
  - `500 Internal Server Error`

---

### üî¥ `DELETE /projectors/actions`
- **Descripci√≥n**: Elimina acciones en lote.
- **Cuerpo**: Lista de `ActionDto`
- **Respuestas**:
  - `200 OK`
  - `400 Bad Request`
  - `500 Internal Server Error`

#### üî∏ ActionDto

Objeto de transferencia de datos (DTO) que representa una acci√≥n. Proporciona una representaci√≥n simplificada de la entidad Action para su uso en el frontend.

| Campo      | Tipo   | Descripci√≥n                  |
|------------|--------|------------------------------|
| actionName | String | Nombre de la acci√≥n.          |

---

### üî¥ `DELETE /projectors/projectors-all`
- **Descripci√≥n**: Elimina todos los proyectores registrados.
- **Respuestas**:
  - `200 OK`
  - `500 Internal Server Error`

---

### üî¥ `DELETE /projectors/commands`
- **Descripci√≥n**: Elimina comandos espec√≠ficos junto a sus eventos.
- **Cuerpo**: Lista de `CommandDto`
- **Respuestas**:
  - `200 OK`
  - `400 Bad Request`
  - `500 Internal Server Error`

#### üî∏ CommandDto

Objeto de transferencia de datos (DTO) que representa un comando. Proporciona una representaci√≥n simplificada de la entidad comando para su uso en el frontend.

| Campo      | Tipo   | Descripci√≥n                                               |
|------------|--------|-----------------------------------------------------------|
| modelName  | String | Nombre del modelo del proyector al que pertenece el comando. |
| action     | String | Acci√≥n que realizar√° el comando.                           |
| command    | String | Instrucci√≥n literal, como un array de bytes o secuencia binaria. |

---

-->
<!--
<a name="hardware-especial"></a> 
# 7. üß∞ Hardware especial - Microcontroladores y modulos a√±adidos.
En esta secci√≥n, se ofrece una visi√≥n detallada del hardware utilizado en este proyecto, junto con observaciones relevantes recopiladas durante el proceso de desarrollo.
    
<a name="esp32"></a> 
## üìå La placa principal - ESP32

La placa utilizada en el proyecto es una **Keyestudio ESP32-WROOM-32 Module Core Board**.  
La Keyestudio ESP32-WROOM-32 es una placa de desarrollo vers√°til dise√±ada para aplicaciones de IoT y hogares inteligentes. Integra el m√≥dulo ESP32-WROOM-32, que ofrece conectividad Wi-Fi y Bluetooth, y es compatible con el Arduino IDE.

**¬øQu√© lenguajes se pueden usar para desarrollar en esta placa?**  
El microcontrolador ESP32 se puede programar en varios lenguajes, dependiendo del entorno de desarrollo y del caso de uso.  
Entre las opciones m√°s populares se encuentran:
- C / C++
- MicroPython
- JavaScript
- Lua
    
### üîπ Especificaciones del Keyestudio ESP32-WROOM-32 XX0H32

Un aspecto importante a mencionar es que el ESP32 generalmente cuenta con un chip de memoria flash de 4MB integrado. Esta memoria flash se particiona para asignar espacio a diferentes prop√≥sitos: almacenamiento del programa (aplicaci√≥n), SPIFFS (o LittleFS en el caso de este proyecto) para almacenamiento de archivos y, opcionalmente, una partici√≥n OTA para actualizaciones de firmware inal√°mbricas.

Es crucial configurar el esquema de particiones correctamente para asignar la cantidad adecuada de espacio a cada prop√≥sito, seg√∫n las necesidades del proyecto.

<table>
    <tr>
        <th>Feature</th>
        <th>Details</th>
        <th>Images</th>
    </tr>
    <tr>
        <td>Microcontroller</td>
        <td>M√≥dulo ESP-WROOM-32</td>
        <td rowspan="9"><img src="https://github.com/user-attachments/assets/7a27f529-b2a2-4130-9c9a-a6fa5d1f1406" alt="ESP32 Front View"></td>
    </tr>
    <tr>
        <td>USB to Serial Port Chip</td>
        <td>CP2102-GMR</td>
    </tr>
    <tr>
        <td>Operating Voltage</td>
        <td>DC 5V</td>
    </tr>
    <tr>
        <td>Operating Current</td>
        <td>80mA (promedio)</td>
    </tr>
    <tr>
        <td>Current Supply</td>
        <td>500mA (m√≠nimo)</td>
    </tr>
    <tr>
        <td>Operating Temperature Range</td>
        <td>-40‚ÑÉ ~ +85‚ÑÉ</td>
    </tr>
    <tr>
        <td>WiFi Mode</td>
        <td>Station / SoftAP / SoftAP+Station / P2P</td>
    </tr>
    <tr>
        <td>WiFi Protocol</td>
        <td>802.11 b/g/n/e/i (hasta 150 Mbps)</td>
    </tr>
    <tr>
        <td>WiFi Frequency Range</td>
        <td>2.4 GHz ~ 2.5 GHz</td>
    </tr>
    <tr>
        <td>Bluetooth Protocol</td>
        <td>Compatible con Bluetooth v4.2 BR/EDR y BLE</td>
        <td rowspan="8"><img src="https://github.com/user-attachments/assets/ded84c16-4fc8-44f1-9782-d8fbb186db21" alt="ESP32 Back View"></td>
    </tr>
    <tr>
        <td>Dimensions</td>
        <td>55mm*26mm*13mm</td>
    </tr>
    <tr>
        <td>Weight</td>
        <td>9.3g</td>
    </tr>
    <tr>
        <td>GPIO Pins</td>
        <td>34 (algunos con soporte ADC/DAC)</td>
    </tr>
    <tr>
        <td>ADC Channels</td>
        <td>18</td>
    </tr>
    <tr>
        <td>DAC Channels</td>
        <td>2</td>
    </tr>
    <tr>
        <td>PWM Channels</td>
        <td>M√∫ltiples</td>
    </tr>
    <tr>
        <td>I2C / SPI / UART</td>
        <td>S√≠ (m√∫ltiples)</td>
    </tr>
</table>

![imagen](https://github.com/user-attachments/assets/7390d1e3-e9a5-4d1f-b9ea-9e96863f41ca)
    
---
       
<a name="rs232"></a> 
## üìå La interfaz de comunicaci√≥n - Convertidor RS232 a TTL

Un **convertidor RS232 a TTL** es un dispositivo utilizado para conectar dos tipos de protocolos de comunicaci√≥n serial: **RS232** y **TTL (Transistor-Transistor Logic)**.  
Estos protocolos operan a diferentes niveles de voltaje y requieren conversi√≥n para comunicarse correctamente.

**Este dispositivo fue esencial en este proyecto para permitir la comunicaci√≥n entre el ESP32 y el proyector que deb√≠a ser controlado.**  
El convertidor RS232 a TTL ajusta los niveles de voltaje de las se√±ales RS232 a niveles compatibles con TTL y viceversa, permitiendo la comunicaci√≥n fiable entre dispositivos con diferentes est√°ndares.

<p>
     <img align="right" src="https://github.com/user-attachments/assets/2f611e96-63cf-4b75-9c10-582fe3969af4">
</p>

### Diferencias entre RS232 y TTL:

1. **RS232**:
   - Est√°ndar cl√°sico utilizado en la comunicaci√≥n entre dispositivos como PCs, m√≥dems o impresoras.
   - Utiliza **voltajes altos** (¬±12V).
   - L√≥gica ‚Äú1‚Äù = +12V, l√≥gica ‚Äú0‚Äù = -12V.

2. **TTL**:
   - Est√°ndar l√≥gico usado en sistemas embebidos y microcontroladores.
   - Usa **niveles bajos de voltaje** (0V = ‚Äú0‚Äù, 3.3V o 5V = ‚Äú1‚Äù).
   - Muy com√∫n en dispositivos modernos como el ESP32.

### Caracter√≠sticas destacadas:

- **Conversi√≥n RS232 a TTL**: Ajusta los niveles de voltaje entre ambos est√°ndares.
- **Bidireccional**: Permite enviar y recibir datos.
- **Level shifting**: Asegura compatibilidad entre se√±ales de diferente voltaje.

> [!Note]  
> Mi unidad espec√≠fica cuenta con un chip **MAX3232 ESE+2416**, encargado de convertir los niveles de voltaje entre RS232 y TTL, garantizando una comunicaci√≥n fiable con el proyector.  
> La distribuci√≥n de pines en mi unidad se puede observar en la siguiente imagen:
   
![rs232](https://github.com/user-attachments/assets/2f9f8a77-e7d4-4c15-86b1-3b8c20906e02)
   
![rs232](https://github.com/user-attachments/assets/3cce1348-7e50-454f-9153-d7c20fea84fa)
    
---
    
<a name="microsd"></a> 
## üìå Almacenamiento externo - M√≥dulo MicroSD

Este m√≥dulo es ideal para agregar almacenamiento masivo al proyecto, permitiendo guardar y recuperar datos desde una tarjeta MicroSD.  
Est√° dise√±ado para usarse con microcontroladores y se comunica mediante una interfaz SPI (Serial Peripheral Interface) de 4 pines, ampliamente soportada por plataformas embebidas como el ESP32.

El m√≥dulo se conecta al ESP32 utilizando los pines SPI predeterminados.  
**Cada pin est√° claramente etiquetado, lo que facilita su conexi√≥n**, especialmente si se consulta la documentaci√≥n del fabricante.

**Tanto el m√≥dulo como el ESP32 operan a 3.3V**, por lo que **no se requiere un adaptador de niveles de voltaje** (level shifter).

Este m√≥dulo es un **LC Technology MicroSD Module**, ampliamente utilizado y confiable, compatible con la mayor√≠a de proyectos de tarjetas MicroSD.

> [!NOTE]  
> El m√≥dulo y el ESP32 operan ambos a 3.3V, por lo tanto no es necesario usar un adaptador de niveles (level shifter), lo cual s√≠ suele ser necesario con otros microcontroladores como Arduino UNO.

<table>
  <tr>
    <th>MicroSD Card Module</th>
    <th>ESP32</th>
    <th>Top side</th>
    <th>Bottom side</th>
  </tr>
  <tr>
    <td>3V3</td>
    <td>3.3V</td>
    <td rowspan="6"><img src="https://github.com/user-attachments/assets/2d517703-273e-46cf-9843-b3f56b074c7a" alt="Image 1" width="300"></td>
    <td rowspan="6"><img src="https://github.com/user-attachments/assets/b9d3420f-26ef-4e08-9700-2a3ea5d3ee13" alt="Image 2" width="300"></td>
  </tr>
  <tr>
    <td>CS</td>
    <td>GPIO 5</td>
  </tr>
  <tr>
    <td>MOSI</td>
    <td>GPIO 23</td>
  </tr>
  <tr>
    <td>CLK</td>
    <td>GPIO 18</td>
  </tr>
  <tr>
    <td>MISO</td>
    <td>GPIO 19</td>
  </tr>
  <tr>
    <td>GND</td>
    <td>GND</td>
  </tr>
</table>
    
<a name="esquema-de-conexion"></a>    
## üìå Esquema de conexi√≥n de componentes.
A continuaci√≥n se muestra el esquema de conexi√≥n de los elementos conectados al ESP32.

### üîπ Conexi√≥n de transceptor RS232 - Max 3232

<table>
     <tr>
          <td>
               Para enviar una se√±al desde un ESP32 a un dispositivo RS232, es necesario hacer coincidir la configuraci√≥n de comunicaci√≥n (velocidad en baudios, bits de datos, bits de parada) y asegurar que el la conexi√≥n a pines sea correcta. Dado que el ESP32 utiliza l√≥gica de 3.3V y el RS232 utiliza niveles de voltaje m√°s altos (¬±12V), debemos usar un convertidor de nivel o un convertidor de RS232 a TTL (como un <strong>MAX3232</strong>) para conectar ambos de forma segura y evitar da√±ar el ESP32.
          </td>
          <td width="250px">  <sub><p>Pincha para agrandar.</p><sub>
               <img align="right" src="https://github.com/user-attachments/assets/ee8df342-79c8-4e29-a25b-4f374f9fa3a2">
          </td>
     </tr>
</table>
   
---
    
### üîπ Conexi√≥n de m√≥dulo Micro SD SPI

<table>
     <tr>
          <td>
El m√≥dulo lector de tarjetas Micro SD se comunica utilizando el protocolo de comunicaci√≥n SPI ( Serial Peripheral Interface ). Podemos conectarlo a nuestro microcontrolador utilizando los pines por defecto destinados a este protocolo.
          </td>
          <td width="250px">  <sub><p>Pincha para agrandar.</p><sub>
               <img align="right" src="https://github.com/user-attachments/assets/57df47df-abae-4b8a-8825-c4d553268a1f">
          </td>
     </tr>
</table>
    
>[!CAUTION]
>Es posible re-asignar los pines pero no es recomendable ni necesario.
    
---

### üîπ Indicadores led para pruebas en fase de desarrollo.
<table>
     <tr>
          <td>
Durante la fase de pruebas, el uso de indicadores LED result√≥ especialmente √∫til para visualizar el estado actual del programa en ejecuci√≥n. Estos LEDs no est√°n destinados para su uso en un entorno real, sino que fueron implementados exclusivamente para la etapa de desarrollo, con el objetivo de facilitar el proceso de depuraci√≥n y verificar el correcto funcionamiento del c√≥digo cargado en el microcontrolador.

En la versi√≥n final del programa, se han integrado cuatro LEDs con las siguientes funciones:

- LED Rojo: Parpadea mientras el agente intenta establecer una conexi√≥n con la red WiFi. Se apaga una vez que el proceso de conexi√≥n finaliza o se aborta. 


- LED Verde: Permanece encendido de forma continua cuando la conexi√≥n a la red se ha realizado con √©xito.

- LED Azul: Se enciende de forma fija una vez que el sistema de archivos local ha sido montado correctamente.

- LED Blanco: Permanece encendido mientras la tarjeta SD est√° siendo utilizada por el microcontrolador.
          </td>
          <td width="250px">  <sub><p>Pincha para agrandar.</p><sub>
               <img align="right" src="https://github.com/user-attachments/assets/3fdcecec-5e09-48f7-acdf-073bc1d6f3a1">
          </td>
     </tr>
</table>
    
---
   
<a name="configuraci√≥n-rs232"></a>    
## üìå Configuraci√≥n de las comunicaciones del puerto RS232.

Para enviar una se√±al desde un ESP32 a un dispositivo RS232, es necesario igualar los ajustes de comunicaci√≥n (velocidad en baudios, bits de datos, bits de parada) y garantizar un cableado correcto. Dado que el ESP32 utiliza l√≥gica de 3.3V y el RS232 utiliza niveles de voltaje m√°s altos (¬±12V), se debe usar un convertidor de nivel o un convertidor de RS232 a TTL (como un MAX232) para interconectar ambos de manera segura y evitar da√±ar el ESP32.

**Entonces, ¬øqu√© debemos hacer?**   
- Identificar los pines TX y RX en la placa para UART2.
- Recopilar informaci√≥n sobre la interfaz del dispositivo RS232.
- Asegurarnos de que nuestro m√≥dulo RS232 incluya un convertidor de nivel como el MAX232 o equivalente.
   
### üìç 0.1 - Identificar los pines TX y RX en la placa para UART2.

El RS232 debe conectarse a los pines TX y RX de la placa ESP32, cuyas ubicaciones pueden variar seg√∫n el modelo espec√≠fico. Para garantizar una conexi√≥n adecuada, es importante utilizar los pines UART correctos. Para la comunicaci√≥n RS232, debemos usar UART2.

#### üî∏ ¬øQu√© son UART0, UART1 y UART2?

UART2 en el ESP32 es una de sus tres interfaces UART (Receptor-Transmisor As√≠ncrono Universal) disponibles, utilizadas para comunicaci√≥n serie. Permite la transmisi√≥n y recepci√≥n de datos a trav√©s de los pines TX y RX, com√∫nmente utilizados para conectar perif√©ricos como m√≥dulos GPS, sensores o adaptadores RS232. A diferencia de UART0 (usado para depuraci√≥n) y UART1 (a menudo vinculado a operaciones de memoria flash), UART2 puede asignarse libremente a pines GPIO disponibles para aplicaciones personalizadas.

Los pines predeterminados para UART2 en el ESP32 son:

- **TX:** `Pin 17`
- **RX:** `Pin 16`
    
```c++
// Definiciones para la comunicaci√≥n RS232.
#define txPinRS232 17  // Pin TX para RS232
#define rxPinRS232 16  // Pin RX para RS232
```

>[!IMPORTANT]
>Estos son los pines com√∫nmente utilizados para la comunicaci√≥n UART2 en muchas placas ESP32 por defecto. Si est√°s utilizando un conjunto diferente de pines o los has reasignado, aseg√∫rate de actualizar los n√∫meros de pin correspondientes en el c√≥digo.

**Imagen de referencia**   
![pinsOfInterestRS232](https://github.com/user-attachments/assets/b5001e0c-9e99-4562-a08e-230bf7694dca)

### üìç 0.2 - Recopilar informaci√≥n sobre la interfaz del dispositivo RS232.
Esta informaci√≥n es necesaria para configurar el protocolo de comunicaci√≥n. La informaci√≥n necesaria es:

- Velocidad en baudios predeterminada.
- Bits de datos.
- Bits de paridad.
- Bits de parada.
   
En mi caso, para mi dispositivo espec√≠fico, tengo la siguiente informaci√≥n proporcionada por el fabricante.

#### Comunicaci√≥n RS232 con el Proyector
##### L√≠neas de Conexi√≥n

<table>
   <tr>
      <th>Se√±al</th>
      <th>Funci√≥n</th>
   </tr>
   <tr>
      <td><b>RxD</b></td>
      <td>Recibe datos desde el computador externo</td>
   </tr>
   <tr>
      <td><b>TxD</b></td>
      <td>Transmite datos al computador externo</td>
   </tr>
   <tr>
      <td><b>GND</b></td>
      <td>Tierra para se√±ales de datos</td>
   </tr>
</table>

##### Configuraci√≥n del Puerto COM

<table>
   <tr>
      <th>Par√°metro</th>
      <th>Valor</th>
   </tr>
   <tr>
      <td><b>Velocidad en Baudios (Predeterminada)</b></td>
      <td>9600</td>
   </tr>
   <tr>
      <td><b>Bits de Datos</b></td>
      <td>8</td>
   </tr>
   <tr>
      <td><b>Paridad</b></td>
      <td>Ninguna</td>
   </tr>
   <tr>
      <td><b>Bit de Parada</b></td>
      <td>1</td>
   </tr>
</table>

>[!Note]
>**¬øPor qu√© es importante esta informaci√≥n?**
>Para establecer una conexi√≥n confiable y comunicarse adecuadamente con el dispositivo, necesitamos configurar par√°metros clave de comunicaci√≥n. Estos ajustes definen la velocidad y estructura del intercambio de datos, garantizando compatibilidad entre dispositivos.
>
>En el siguiente ejemplo:
>```c++
>mySerialPort.begin(9600, SERIAL_8N1, 16, 17); // (Velocidad en baudios, configuraci√≥n, RX, TX)
>```

### üìç 0.3 - Conversi√≥n de Nivel L√≥gico
El ESP32 opera a l√≥gica TTL de 3.3V, mientras que el RS232 opera a niveles l√≥gicos de ¬±12V. Conectarlos directamente da√±ar√° el ESP32.

Para convertir los niveles de se√±al, utiliza un adaptador/m√≥dulo de RS232 a TTL, como:
- M√≥dulo MAX232 (com√∫n y econ√≥mico)
- M√≥dulo SP3232 (mejor para l√≥gica de 3.3V)

Estos m√≥dulos cambiar√°n los niveles de voltaje de manera segura.

>[!TIP]
>En mi caso, usar√© un MAX232. Para verificar tu propio chip, inspecciona tu m√≥dulo, encuentra el chip instalado y toma nota de su nombre.
>
>![imagen](https://github.com/user-attachments/assets/f043ed6b-b8a6-4fc0-8619-04fa217aed6c)

##### üî∏ ¬øQu√© hace el MAX232?

El MAX232 se utiliza para convertir niveles de voltaje entre los est√°ndares de comunicaci√≥n serie TTL (L√≥gica Transistor-Transistor) y RS-232.
- L√≥gica TTL (0V y 5V o 3.3V): Utilizada por microcontroladores (como Arduino, PIC o AVR).
- Se√±ales RS-232 (-12V a +12V o -10V a +10V): Utilizadas para puertos serie en PCs y otros dispositivos de comunicaci√≥n.

**C√≥mo Funciona:**
- El MAX232 toma una fuente de alimentaci√≥n de 5V y genera internamente los voltajes positivos y negativos m√°s altos necesarios para la comunicaci√≥n RS-232 mediante bombas de carga.
- Tiene condensadores incorporados (se necesitan externos en algunas versiones) para la conversi√≥n de voltaje.
- Proporciona dos drivers y dos receptores, lo que significa que puede manejar dos l√≠neas de transmisi√≥n y dos de recepci√≥n.

### üìç 1 - Conexiones de cableado.

Despu√©s de identificar los pines para transmisi√≥n y recepci√≥n de datos, podemos proceder a cablear el transceptor a la placa ESP32.
Para conectar correctamente, consulta las anotaciones en el m√≥dulo. **`TX`** significa Transmisi√≥n y **`RX`** significa Recepci√≥n.

![srs232](https://github.com/user-attachments/assets/3cce1348-7e50-454f-9153-d7c20fea84fa)

>[!TIP]
>El esquema de colores com√∫n es el representado en la imagen.
>- Negro para Tierra (GND).
>- Rojo para VCC o positivo (3.3v del ESP32).
>- Amarillo (o Naranja) para Transmisi√≥n (TX).
>- Verde para Recepci√≥n (RX).

Conecta los cables a los pines designados seg√∫n los pasos anteriores. En total, hay cuatro conexiones que deben realizarse: `+3.3v`, `GND`, `TX` y `RX`.

![circuito](https://github.com/user-attachments/assets/ee62e48a-1c9b-4037-a5cf-2968279c8803)

### üìç 2 - Configurar la variable en el programa.

Ahora es el momento de definir las sustituciones basadas en texto para los pines y configuraciones de puerto que hemos anotado hasta ahora.

```c++
// Biblioteca para comunicaci√≥n RS232
#include <HardwareSerial.h>
// Definiciones para comunicaci√≥n RS232.
#define txPinRS232 17  // Pin TX para RS232
#define rxPinRS232 16  // Pin RX para RS232
// Configuraci√≥n de comunicaci√≥n serie del proyector
#define projectorRate 9600  // Velocidad en baudios: 9600
// Bits de Datos: 8
// Paridad: Ninguna
// Bits de Parada: 1
```

### üìç 3 - Inicializar la clase HardwareSerial con un tipo UART.

La clase `HardwareSerial` permite utilizar los UARTs de hardware del ESP32.

```c++
// Usar UART2 en el ESP32
HardwareSerial mySerialPort(2);
```

>[!Note]
>UART (Receptor-Transmisor As√≠ncrono Universal) es un protocolo de comunicaci√≥n serie utilizado en el ESP32 para permitir la comunicaci√≥n entre dispositivos como sensores, microcontroladores y computadoras. Es una forma simple y eficiente de enviar y recibir datos sin requerir una se√±al de reloj.

**Explicaci√≥n:**

El ESP32 tiene tres UARTs de hardware:
- UART0 ‚Üí Se utiliza para depuraci√≥n (Serial predeterminado).
- UART1 ‚Üí Normalmente conectado a la memoria flash integrada (evita usarlo).
- UART2 ‚Üí Disponible para uso general (mejor opci√≥n para comunicaci√≥n RS232).

Por lo tanto, al usar `HardwareSerial mySerialPort(2);` le estoy indicando al ESP32 que use UART2 para comunicaci√≥n serie.

Por defecto, UART2 est√° asignado a:
- TX ‚Üí GPIO17
- RX ‚Üí GPIO16

Sin embargo, estos pines se pueden cambiar usando:

```c++
mySerial.begin(9600, SERIAL_8N1, txPinRS232, rxPinRS232);  // RX en GPIO16, TX en GPIO17
```

### üìç 4 - Realizar un handshake si es necesario.

En este punto, el puerto de comunicaci√≥n serie se ha inicializado, pero a√∫n necesitas establecer una conexi√≥n con el dispositivo (por ejemplo, un proyector). Esto generalmente implica enviar un "handshake" inicial o alg√∫n comando para verificar que la conexi√≥n est√° activa. En mi caso espec√≠fico, no es necesario un handshake ya que el dispositivo no lo requiere.

### üìç 5 - Enviar datos al puerto.
Para enviar datos desde el ESP32 al dispositivo RS232, puedes usar la funci√≥n `print()`, `println()` o `write()`. Estas funciones te permiten enviar cadenas o arreglos de bytes sobre la comunicaci√≥n serie.
        
>[!TIP]
>La comunicaci√≥n RS232 se realiza t√≠picamente utilizando arreglos de bytes (tambi√©n conocidos como datos binarios sin procesar). Los datos se transmiten como una secuencia de bytes, donde cada byte representa 8 bits de informaci√≥n.
>Esto transmitir√° el arreglo de btyes hexadecimales `byteArray` al dispositivo RS232.

##### üî∏ Para escribir un arreglo de bytes, utiliza las siguientes instrucciones.
Para escribir el arreglo de bytes para este comando:

<table border="1">
   <tr>
      <th>Comando</th>
      <th>Hexadecimal</th>
      <th>Descripci√≥n</th>
   </tr>
   <tr>
      <td>* 0 IR 001\r</td>
      <td>2A 20 30 20 49 52 20 30 30 31 0D</td>
      <td>Encender</td>
   </tr>
</table>

```c++
// Definir el arreglo de bytes que corresponde a tu comando
byte comando[] = {
0x2A, 0x20, 0x30, 0x20, 0x49, 0x52, 0x20, 0x30, 0x33, 0x32, 0x0D
};

// Almacena la longitud final del arreglo.
int numBytes = 11;

// Escribe al puerto los datos especificando su longitud (implementacion iterada del write normal).
rs232Port.write(byteArray, numBytes);
}
```
    
---
    
<a name="configuraci√≥n-spi"></a>
## üìå Configuraci√≥n de la tarjeta MicroSD con interfaz SPI
El m√≥dulo de tarjeta microSD se comunica mediante el protocolo SPI (Serial Peripheral Interface). Puedes conectarlo al ESP32 usando los pines SPI predeterminados.

### üìç 1 - Conexi√≥n del m√≥dulo al ESP32
La conexi√≥n del m√≥dulo est√° etiquetada y podemos identificar f√°cilmente el pin correspondiente en la placa con la imagen de referencia del fabricante.

>[!CAUTION]
>Estos pines pueden reasignarse usando HSPI y VSPI; sin embargo, **no se recomienda** en la mayor√≠a de casos debido a posibles diferencias en rendimiento, compatibilidad con librer√≠as existentes y optimizaciones de hardware predeterminadas.

#### üîπ Colores de cableado
En configuraciones t√≠picas para comunicaci√≥n SPI:
- **MISO**: Amarillo
- **MOSI**: Verde
- **CLK**: Azul
- **CS**: Morado o naranja

Estos c√≥digos de color ayudan a distinguir las se√±ales SPI, facilitando la conexi√≥n correcta entre dispositivos. Siempre verifica la codificaci√≥n de colores de tus componentes espec√≠ficos.

| Pin del m√≥dulo | ESP32       | Color cable |
|----------------|-------------|-------------|
| 3V3            | 3.3V        | üî¥ ROJO     |
| CS             | GPIO 5      | üü£ MORADO   |
| MOSI           | GPIO 23     | üü¢ VERDE    |
| CLK            | GPIO 18     | üîµ AZUL     |
| MISO           | GPIO 19     | üü° AMARILLO |
| GND            | GND         | ‚ö´ NEGRO    |

![Circuito MicroSD](https://github.com/user-attachments/assets/1e3681d9-4a9f-4154-be5e-87181af45af2)

### üìç 2 - Definici√≥n de pines
Define las conexiones en el programa usando sustituciones de texto:
```c++
// Definiciones para tarjeta SD
#define sdCardMOSI 23
#define sdCardMISO 19
#define sdCardClock 18
#define sdCardChipSelect 5
```

**Explicaci√≥n de las funciones de los pines**    
<table border="1">
  <tr>
    <th>Pin del m√≥dulo MicroSD</th>
    <th>Pin ESP32</th>
    <th>Descripci√≥n</th>
  </tr>
  <tr>
    <td>3V3</td>
    <td>3.3V</td>
    <td>Alimenta el m√≥dulo con 3.3V. El m√≥dulo microSD opera a 3.3V y el ESP32 proporciona este voltaje.</td>
  </tr>
  <tr>
    <td>CS</td>
    <td>GPIO 5</td>
    <td>Chip Select (CS): Selecciona la tarjeta SD para comunicaci√≥n. Cuando CS est√° en BAJO (LOW), el m√≥dulo est√° activo y listo para comunicarse.</td>
  </tr>
  <tr>
    <td>MOSI</td>
    <td>GPIO 23</td>
    <td>Master Out Slave In (MOSI): L√≠nea de datos donde el maestro (ESP32) env√≠a datos a la tarjeta microSD.</td>
  </tr>
  <tr>
    <td>CLK</td>
    <td>GPIO 18</td>
    <td>Clock (CLK): Proporciona la se√±al de reloj para sincronizar la transmisi√≥n de datos entre el ESP32 y la tarjeta microSD.</td>
  </tr>
  <tr>
    <td>MISO</td>
    <td>GPIO 19</td>
    <td>Master In Slave Out (MISO): L√≠nea de datos donde la tarjeta microSD env√≠a datos al maestro (ESP32).</td>
  </tr>
  <tr>
    <td>GND</td>
    <td>GND</td>
    <td>Tierra (GND): Conecta la tierra del m√≥dulo microSD a la tierra del ESP32 para completar el circuito.</td>
  </tr>
</table>
    
### üìç 3 - Probar conexi√≥n con script de prueba
El IDE de Arduino incluye varios ejemplos que muestran c√≥mo manejar archivos en tarjetas microSD usando el ESP32. Ve a `Archivo > Ejemplos > SD(esp32) > SD_Test`, o copia el c√≥digo del script de prueba m√°s abajo.

>[!CAUTION]
> **La tarjeta debe estar formateada en FAT32** y se deben incluir las librer√≠as relevantes. Estas librer√≠as requieren componentes espec√≠ficos instalados en el IDE de Arduino para funcionar correctamente, especialmente para la interfaz con tarjetas SD y el bus SPI.

#### Script de prueba. 
<details>
  <summary> üëâ Click aqu√≠ para mostrar. </summary>
      
   ```cpp
   /*
    * pin 1 - not used          |  Micro SD card     |
    * pin 2 - CS (SS)           |                   /
    * pin 3 - DI (MOSI)         |                  |__
    * pin 4 - VDD (3.3V)        |                    |
    * pin 5 - SCK (SCLK)        | 8 7 6 5 4 3 2 1   /
    * pin 6 - VSS (GND)         | ‚ñÑ ‚ñÑ ‚ñÑ ‚ñÑ ‚ñÑ ‚ñÑ ‚ñÑ ‚ñÑ  /
    * pin 7 - DO (MISO)         | ‚ñÄ ‚ñÄ ‚ñà ‚ñÄ ‚ñà ‚ñÄ ‚ñÄ ‚ñÄ |
    * pin 8 - not used          |_________________|
    *                             ‚ïë ‚ïë ‚ïë ‚ïë ‚ïë ‚ïë ‚ïë ‚ïë
    *                     ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïë ‚ïë ‚ïë ‚ïë ‚ïë ‚ïë ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    *                     ‚ïë         ‚ïë ‚ïë ‚ïë ‚ïë ‚ïë ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó    ‚ïë
    *                     ‚ïë   ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïë ‚ïë ‚ïë ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó  ‚ïë    ‚ïë
    * Connections for     ‚ïë   ‚ïë   ‚ïî‚ïê‚ïê‚ïê‚ï©‚ïê‚ïë‚ïê‚ïë‚ïê‚ïê‚ïê‚ïó   ‚ïë  ‚ïë    ‚ïë
    * full-sized          ‚ïë   ‚ïë   ‚ïë   ‚ïî‚ïê‚ïù ‚ïë   ‚ïë   ‚ïë  ‚ïë    ‚ïë
    * SD card             ‚ïë   ‚ïë   ‚ïë   ‚ïë   ‚ïë   ‚ïë   ‚ïë  ‚ïë    ‚ïë
    * Pin name         |  -  DO  VSS SCK VDD VSS DI CS    -  |
    * SD pin number    |  8   7   6   5   4   3   2   1   9 /
    *                  |                                  ‚ñà/
    *                  |__‚ñç___‚ñä___‚ñà___‚ñà___‚ñà___‚ñà___‚ñà___‚ñà___/
    *
    * Note:  The SPI pins can be manually configured by using `SPI.begin(sck, miso, mosi, cs).`
    *        Alternatively, you can change the CS pin and use the other default settings by using `SD.begin(cs)`.
    *
    * +--------------+---------+-------+----------+----------+----------+----------+----------+
    * | SPI Pin Name | ESP8266 | ESP32 | ESP32‚ÄëS2 | ESP32‚ÄëS3 | ESP32‚ÄëC3 | ESP32‚ÄëC6 | ESP32‚ÄëH2 |
    * +==============+=========+=======+==========+==========+==========+==========+==========+
    * | CS (SS)      | GPIO15  | GPIO5 | GPIO34   | GPIO10   | GPIO7    | GPIO18   | GPIO0    |
    * +--------------+---------+-------+----------+----------+----------+----------+----------+
    * | DI (MOSI)    | GPIO13  | GPIO23| GPIO35   | GPIO11   | GPIO6    | GPIO19   | GPIO25   |
    * +--------------+---------+-------+----------+----------+----------+----------+----------+
    * | DO (MISO)    | GPIO12  | GPIO19| GPIO37   | GPIO13   | GPIO5    | GPIO20   | GPIO11   |
    * +--------------+---------+-------+----------+----------+----------+----------+----------+
    * | SCK (SCLK)   | GPIO14  | GPIO18| GPIO36   | GPIO12   | GPIO4    | GPIO21   | GPIO10   |
    * +--------------+---------+-------+----------+----------+----------+----------+----------+
    *
    * For more info see file README.md in this library or on URL:
    * https://github.com/espressif/arduino-esp32/tree/master/libraries/SD
    */
   
   #include "FS.h"
   #include "SD.h"
   #include "SPI.h"
   
   /*
   Uncomment and set up if you want to use custom pins for the SPI communication
   #define REASSIGN_PINS
   int sck = -1;
   int miso = -1;
   int mosi = -1;
   int cs = -1;
   */
   
   void listDir(fs::FS &fs, const char *dirname, uint8_t levels) {
     Serial.printf("Listing directory: %s\n", dirname);
   
     File root = fs.open(dirname);
     if (!root) {
       Serial.println("Failed to open directory");
       return;
     }
     if (!root.isDirectory()) {
       Serial.println("Not a directory");
       return;
     }
   
     File file = root.openNextFile();
     while (file) {<a name="custom_anchor_name"></a>
       if (file.isDirectory()) {
         Serial.print("  DIR : ");
         Serial.println(file.name());
         if (levels) {
           listDir(fs, file.path(), levels - 1);
         }
       } else {
         Serial.print("  FILE: ");
         Serial.print(file.name());
         Serial.print("  SIZE: ");
         Serial.println(file.size());
       }
       file = root.openNextFile();
     }
   }
   
   void createDir(fs::FS &fs, const char *path) {
     Serial.printf("Creating Dir: %s\n", path);
     if (fs.mkdir(path)) {
       Serial.println("Dir created");
     } else {
       Serial.println("mkdir failed");
     }
   }
   
   void removeDir(fs::FS &fs, const char *path) {
     Serial.printf("Removing Dir: %s\n", path);
     if (fs.rmdir(path)) {
       Serial.println("Dir removed");
     } else {
       Serial.println("rmdir failed");
     }
   }
   
   void readFile(fs::FS &fs, const char *path) {
     Serial.printf("Reading file: %s\n", path);
   
     File file = fs.open(path);
     if (!file) {
       Serial.println("Failed to open file for reading");
       return;
     }
   
     Serial.print("Read from file: ");
     while (file.available()) {
       Serial.write(file.read());
     }
     file.close();
   }
   
   void writeFile(fs::FS &fs, const char *path, const char *message) {
     Serial.printf("Writing file: %s\n", path);
   
     File file = fs.open(path, FILE_WRITE);
     if (!file) {
       Serial.println("Failed to open file for writing");
       return;
     }
     if (file.print(message)) {
       Serial.println("File written");
     } else {
       Serial.println("Write failed");
     }
     file.close();
   }
   
   void appendFile(fs::FS &fs, const char *path, const char *message) {
     Serial.printf("Appending to file: %s\n", path);
   
     File file = fs.open(path, FILE_APPEND);
     if (!file) {
       Serial.println("Failed to open file for appending");
       return;
     }
     if (file.print(message)) {
       Serial.println("Message appended");
     } else {
       Serial.println("Append failed");
     }
     file.close();
   }
   
   void renameFile(fs::FS &fs, const char *path1, const char *path2) {
     Serial.printf("Renaming file %s to %s\n", path1, path2);
     if (fs.rename(path1, path2)) {
       Serial.println("File renamed");
     } else {
       Serial.println("Rename failed");
     }
   }
   
   void deleteFile(fs::FS &fs, const char *path) {
     Serial.printf("Deleting file: %s\n", path);
     if (fs.remove(path)) {
       Serial.println("File deleted");
     } else {
       Serial.println("Delete failed");
     }
   }
   
   void testFileIO(fs::FS &fs, const char *path) {
     File file = fs.open(path);
     static uint8_t buf[512];
     size_t len = 0;
     uint32_t start = millis();
     uint32_t end = start;
     if (file) {
       len = file.size();
       size_t flen = len;
       start = millis();
       while (len) {
         size_t toRead = len;
         if (toRead > 512) {
           toRead = 512;
         }
         file.read(buf, toRead);
         len -= toRead;
       }
       end = millis() - start;
       Serial.printf("%u bytes read for %lu ms\n", flen, end);
       file.close();
     } else {
       Serial.println("Failed to open file for reading");
     }
   
     file = fs.open(path, FILE_WRITE);
     if (!file) {
       Serial.println("Failed to open file for writing");
       return;
     }
   
     size_t i;
     start = millis();
     for (i = 0; i < 2048; i++) {
       file.write(buf, 512);
     }
     end = millis() - start;
     Serial.printf("%u bytes written for %lu ms\n", 2048 * 512, end);
     file.close();
   }
   
   void setup() {
     Serial.begin(115200);
   
   #ifdef REASSIGN_PINS
     SPI.begin(sck, miso, mosi, cs);
     if (!SD.begin(cs)) {
   #else
     if (!SD.begin()) {
   #endif
       Serial.println("Card Mount Failed");
       return;
     }
     uint8_t cardType = SD.cardType();
   
     if (cardType == CARD_NONE) {
       Serial.println("No SD card attached");
       return;
     }
   
     Serial.print("SD Card Type: ");
     if (cardType == CARD_MMC) {
       Serial.println("MMC");
     } else if (cardType == CARD_SD) {
       Serial.println("SDSC");
     } else if (cardType == CARD_SDHC) {
       Serial.println("SDHC");
     } else {
       Serial.println("UNKNOWN");
     }
   
     uint64_t cardSize = SD.cardSize() / (1024 * 1024);
     Serial.printf("SD Card Size: %lluMB\n", cardSize);
   
     listDir(SD, "/", 0);
     createDir(SD, "/mydir");
     listDir(SD, "/", 0);
     removeDir(SD, "/mydir");
     listDir(SD, "/", 2);
     writeFile(SD, "/hello.txt", "Hello ");
     appendFile(SD, "/hello.txt", "World!\n");
     readFile(SD, "/hello.txt");
     deleteFile(SD, "/foo.txt");
     renameFile(SD, "/hello.txt", "/foo.txt");
     readFile(SD, "/foo.txt");
     testFileIO(SD, "/test.txt");
     Serial.printf("Total space: %lluMB\n", SD.totalBytes() / (1024 * 1024));
     Serial.printf("Used space: %lluMB\n", SD.usedBytes() / (1024 * 1024));
   }
   
   void loop() {}
   
   ```
</details> 

-->
<!--
# 8. üìÅ Carga de datos al servidor.
Para cargar datos en el servidor, el administrador dispone de un formulario sencillo donde debe subir dos archivos CSV. Estos archivos contienen toda la informaci√≥n necesaria para que el sistema pueda:
- üÜî Identificar los proyectores
- üìç Ubicarlos correctamente
- üîé Filtrarlos seg√∫n distintos criterios
- üîó Relacionarlos con las instrucciones disponibles

>[!CAUTION]
>Para que el proceso funcione correctamente, los archivos deben estar configurados y formateados de manera precisa.

 En esta secci√≥n se describen las normas y observaciones esenciales que deben seguirse para que la carga de datos se realice con √©xito y los archivos sean interpretados correctamente por el sistema.

---
<a name="carga-datos-servidor"></a>
Escribir seccion de carga de datos.

-->

---
Proyecto desarrollado, codificado y documentado por [David Jason Gianmoena](https://www.linkedin.com/in/jason-david-gianmoena-959195310/) bajo la supervisi√≥n de los docentes [Francisco Manuel Benitez Chico](https://www.linkedin.com/in/franciscobenitezchico/) y [Manuel Francisco Aparicio](https://www.linkedin.com/in/manuelfrancisco/) para su implementaci√≥n en el centro [IES J√°ndula](https://blogsaverroes.juntadeandalucia.es/iesjandula/) en la localidad de And√∫jar.
